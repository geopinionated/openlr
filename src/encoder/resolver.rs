use tracing::warn;

use crate::{
    Bearing, Coordinate, DirectedGraph, EncoderConfig, EncoderError, ExpansionPaths,
    IntermediateLocation, Length, LineLocation, LocationError, ShortestRoute,
    shortest_path_location,
};

/// Location Reference Point (LRP) generated by the encoder during the resolver step.
/// Includes the line being represented by this LRP and the shortest-path to the next LRP.
#[derive(Debug, Clone, PartialEq)]
pub struct LocRefPoint<EdgeId> {
    /// The (non-empty) shortest path to the next LRP.
    /// The line the LRP refers to is the first edge of the path.
    pub path: Vec<EdgeId>,
    /// The LRP coordinate.
    pub coordinate: Coordinate,
    /// True only if this is the last LRP of the location.
    pub is_last: bool,
    /// The bearing of the LRP line.
    pub bearing: Bearing,
}

impl<EdgeId: Copy> LocRefPoint<EdgeId> {
    /// Constructs a new LRP based on a node.
    fn from_node<G>(
        config: &EncoderConfig,
        graph: &G,
        path: Vec<EdgeId>,
    ) -> Result<Self, EncoderError>
    where
        G: DirectedGraph<EdgeId = EdgeId>,
    {
        Self::new(config, graph, path, false).ok_or(EncoderError::LrpConstructionFailed)
    }

    /// Constructs a new LRP based on the last node.
    fn from_last_node<G>(
        config: &EncoderConfig,
        graph: &G,
        edge: EdgeId,
    ) -> Result<Self, EncoderError>
    where
        G: DirectedGraph<EdgeId = EdgeId>,
    {
        Self::new(config, graph, vec![edge], true).ok_or(EncoderError::LrpConstructionFailed)
    }

    fn length<G>(&self, graph: &G) -> Length
    where
        G: DirectedGraph<EdgeId = EdgeId>,
    {
        self.path
            .iter()
            .filter_map(|&e| graph.get_edge_length(e))
            .sum()
    }

    fn new<G>(
        config: &EncoderConfig,
        graph: &G,
        mut path: Vec<EdgeId>,
        is_last: bool,
    ) -> Option<Self>
    where
        G: DirectedGraph<EdgeId = EdgeId>,
    {
        let lrp = if is_last {
            let edge = path.pop()?;
            let coordinate = graph.get_vertex_coordinate(graph.get_edge_end_vertex(edge)?)?;
            let projection = graph.get_edge_length(edge)?;

            let bearing_distance = config.bearing_distance.reverse();
            let bearing = graph.get_edge_bearing_between(edge, projection, bearing_distance)?;

            Self {
                path,
                coordinate,
                is_last,
                bearing,
            }
        } else {
            let edge = *path.first()?;
            let coordinate = graph.get_vertex_coordinate(graph.get_edge_start_vertex(edge)?)?;
            let projection = Length::ZERO;

            let bearing_distance = config.bearing_distance;
            let bearing = graph.get_edge_bearing_between(edge, projection, bearing_distance)?;

            Self {
                path,
                coordinate,
                is_last,
                bearing,
            }
        };

        Some(lrp)
    }
}

/// Resolves all the LRPs that should be necessary to encode the given line, and its expansion.
pub fn resolve_lrps<G: DirectedGraph>(
    config: &EncoderConfig,
    graph: &G,
    line: &LineLocation<G::EdgeId>,
    expansion: &ExpansionPaths<G::EdgeId>,
) -> Result<Vec<LocRefPoint<G::EdgeId>>, EncoderError> {
    let mut location: Vec<G::EdgeId> = expansion.expand_line_path(line);

    let last_edge = if let Some(&last_edge) = location.last() {
        last_edge
    } else {
        return Err(LocationError::Empty.into());
    };

    let last_lrp = LocRefPoint::from_last_node(config, graph, last_edge)?;
    let mut lrps = vec![];

    // Step - 3 Determine coverage of the location by a shortest-path.
    // Find shortest paths until the whole location is covered by a concatenation of these.
    while !location.is_empty() {
        match shortest_path_location(graph, &location, config.max_lrp_distance)? {
            // Step – 4 Check whether the calculated shortest-path covers the location completely.
            ShortestRoute::Location => {
                let lrp = LocRefPoint::from_node(config, graph, location)?;
                lrps.push(lrp);
                break;
            }
            // Step – 6 Restart shortest path calculation between the new intermediate location
            // reference point and the end of the location.
            ShortestRoute::Intermediate(intermediate) => {
                let IntermediateLocation { location_index, .. } = intermediate;
                let mut intermediates = intermediate_lrps(config, graph, &location, intermediate)?;
                lrps.append(&mut intermediates);
                location.drain(..location_index);
            }
            ShortestRoute::NotFound => {
                return Err(EncoderError::RouteNotFound);
            }
        }
    }

    lrps.push(last_lrp);

    // TODO: determine new intermediate LRPs if the maximum distance was exceeded.
    if let Some(lrp) = lrps
        .iter()
        .find(|lrp| lrp.length(graph) > config.max_lrp_distance)
    {
        warn!("Maximum LRP distance exceeded by {lrp:?}");
    }

    Ok(lrps)
}

fn intermediate_lrps<G: DirectedGraph>(
    config: &EncoderConfig,
    graph: &G,
    location: &[G::EdgeId],
    intermediate: IntermediateLocation,
) -> Result<Vec<LocRefPoint<G::EdgeId>>, EncoderError> {
    let location = location[..intermediate.location_index].to_vec();
    let lrp = LocRefPoint::from_node(config, graph, location)?;
    Ok(vec![lrp])
}
