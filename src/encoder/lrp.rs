use std::fmt::Debug;
use std::ops::Deref;

use tracing::{debug, trace};

use crate::{
    Coordinate, DirectedGraph, EncoderConfig, EncoderError, Frc, Length, Line, LineAttributes,
    Offset, Offsets, PathAttributes, Point,
};

#[derive(Debug, Clone, PartialEq)]
pub struct LocRefPoints<EdgeId> {
    pub lrps: Vec<LocRefPoint<EdgeId>>,
    pub pos_offset: Length,
    pub neg_offset: Length,
}

impl<EdgeId> Deref for LocRefPoints<EdgeId> {
    type Target = Vec<LocRefPoint<EdgeId>>;
    fn deref(&self) -> &Self::Target {
        &self.lrps
    }
}

impl<EdgeId> From<Vec<LocRefPoint<EdgeId>>> for LocRefPoints<EdgeId> {
    fn from(lrps: Vec<LocRefPoint<EdgeId>>) -> Self {
        Self {
            lrps,
            pos_offset: Length::ZERO,
            neg_offset: Length::ZERO,
        }
    }
}

/// Location Reference Point (LRP) generated by the encoder during the resolver step.
/// Includes the line being represented by this LRP and the shortest-path to the next LRP.
#[derive(Debug, Clone, PartialEq)]
pub struct LocRefPoint<EdgeId> {
    /// The (non-empty) shortest path to the next LRP.
    /// The line the LRP refers to is the first edge of this path.
    pub edges: Vec<EdgeId>,
    /// The Location Reference Point.
    pub point: Point,
    /// If the LRP was built from a line (instead of direclty from a node), this coordinate
    /// represents the location of where the LRP was projected onto the line.
    pub projection_coordinate: Option<Coordinate>,
}

impl<EdgeId: Copy> LocRefPoint<EdgeId> {
    /// Constructs a new LRP based on a node.
    pub fn node<G>(config: &EncoderConfig, graph: &G, edges: Vec<EdgeId>) -> Option<Self>
    where
        G: DirectedGraph<EdgeId = EdgeId>,
    {
        let edge = *edges.first()?;
        let coordinate = graph.get_vertex_coordinate(graph.get_edge_start_vertex(edge)?)?;
        let projection = Length::ZERO;
        let bearing_distance = config.bearing_distance;

        let lfrcnp = edges.iter().filter_map(|&e| graph.get_edge_frc(e)).max();
        let dnp: Length = edges.iter().filter_map(|&e| graph.get_edge_length(e)).sum();

        let line = LineAttributes {
            frc: graph.get_edge_frc(edge)?,
            fow: graph.get_edge_fow(edge)?,
            bearing: graph.get_edge_bearing(edge, projection, bearing_distance)?,
        };

        let path = PathAttributes {
            lfrcnp: lfrcnp.unwrap_or(Frc::Frc7),
            dnp,
        };

        Some(Self {
            edges,
            point: Point {
                coordinate,
                line,
                path: Some(path),
            },
            projection_coordinate: None,
        })
    }

    /// Constructs a new LRP based on the last node.
    pub fn last_node<G>(config: &EncoderConfig, graph: &G, edge: EdgeId) -> Option<Self>
    where
        G: DirectedGraph<EdgeId = EdgeId>,
    {
        let coordinate = graph.get_vertex_coordinate(graph.get_edge_end_vertex(edge)?)?;
        let projection = graph.get_edge_length(edge)?;
        let bearing_distance = config.bearing_distance.reverse();

        let line = LineAttributes {
            frc: graph.get_edge_frc(edge)?,
            fow: graph.get_edge_fow(edge)?,
            bearing: graph.get_edge_bearing(edge, projection, bearing_distance)?,
        };

        Some(Self {
            edges: vec![],
            point: Point {
                coordinate,
                line,
                path: None,
            },
            projection_coordinate: None,
        })
    }

    /// Constructs a new LRP based on a line.
    pub fn line<G>(
        config: &EncoderConfig,
        graph: &G,
        edge: EdgeId,
        coordinate: Coordinate,
    ) -> Option<Self>
    where
        G: DirectedGraph<EdgeId = EdgeId>,
    {
        let projection = graph.get_distance_along_edge(edge, coordinate)?;
        let bearing_distance = config.bearing_distance;
        let lfrcnp = graph.get_edge_frc(edge)?;
        let dnp = graph.get_edge_length(edge)? - projection;

        let line = LineAttributes {
            frc: graph.get_edge_frc(edge)?,
            fow: graph.get_edge_fow(edge)?,
            bearing: graph.get_edge_bearing(edge, projection, bearing_distance)?,
        };

        Some(Self {
            edges: vec![edge],
            point: Point {
                coordinate,
                line,
                path: Some(PathAttributes { lfrcnp, dnp }),
            },
            projection_coordinate: Some(coordinate),
        })
    }

    /// Constructs a new LRP based on the last line.
    pub fn last_line<G>(
        config: &EncoderConfig,
        graph: &G,
        edge: EdgeId,
        coordinate: Coordinate,
    ) -> Option<Self>
    where
        G: DirectedGraph<EdgeId = EdgeId>,
    {
        let projection = graph.get_distance_along_edge(edge, coordinate)?;
        let bearing_distance = config.bearing_distance.reverse();

        let line = LineAttributes {
            frc: graph.get_edge_frc(edge)?,
            fow: graph.get_edge_fow(edge)?,
            bearing: graph.get_edge_bearing(edge, projection, bearing_distance)?,
        };

        Some(Self {
            edges: vec![],
            point: Point {
                coordinate,
                line,
                path: None,
            },
            projection_coordinate: Some(coordinate),
        })
    }
}

impl<EdgeId: Copy + Debug> LocRefPoints<EdgeId> {
    /// Trim the LRPs according to the positive and negative offsets.
    pub fn trim<G>(mut self, config: &EncoderConfig, graph: &G) -> Result<Self, EncoderError>
    where
        G: DirectedGraph<EdgeId = EdgeId>,
    {
        debug!("Trimming {} LRPs", self.lrps.len());

        self.lrps.reverse();
        while let Some(lrp) = self.lrps.last()
            && self.pos_offset >= lrp.point.dnp()
        {
            trace!("Trimming front {} {}", self.pos_offset, lrp.point.dnp());
            self.pos_offset -= lrp.point.dnp();
            self.lrps.pop();
        }
        self.lrps.reverse();

        while let Some(lrp) = self.lrps.iter().rev().nth(1)
            && self.neg_offset >= lrp.point.dnp()
        {
            trace!("Trimming back {} {}", self.neg_offset, lrp.point.dnp());
            self.neg_offset -= lrp.point.dnp();
            self.lrps.pop();
        }

        if self.lrps.len() < 2 {
            return Err(EncoderError::InvalidLrpOffsets);
        }

        let mut lrps_rev = self.lrps.iter_mut().rev();

        if let Some(last_lrp) = lrps_rev.next().filter(|lrp| !lrp.point.is_last())
            && let Some(&last_edge) = lrps_rev.next().and_then(|lrp| lrp.edges.last())
        {
            // the last LRP was trimmed: update the remaining one to become the last LRP
            *last_lrp = if let Some(coordinate) = last_lrp.projection_coordinate {
                LocRefPoint::last_line(config, graph, last_edge, coordinate)
            } else {
                LocRefPoint::last_node(config, graph, last_edge)
            }
            .ok_or(EncoderError::InvalidLrpOffsets)?;
        }

        Ok(self)
    }
}

impl<EdgeId> From<LocRefPoints<EdgeId>> for Line {
    fn from(lrps: LocRefPoints<EdgeId>) -> Self {
        let LocRefPoints {
            lrps,
            pos_offset,
            neg_offset,
        } = lrps;

        debug_assert!(lrps.len() > 1);
        let pos = Offset::relative(pos_offset, lrps[0].point.dnp());
        let neg = Offset::relative(neg_offset, lrps[lrps.len() - 2].point.dnp());

        Self {
            points: lrps.into_iter().map(|lrp| lrp.point).collect(),
            offsets: Offsets { pos, neg },
        }
    }
}

#[cfg(test)]
mod tests {
    use test_log::test;

    use super::*;
    use crate::graph::tests::{EdgeId, NETWORK_GRAPH, NetworkGraph};
    use crate::{Bearing, Coordinate, Fow};

    #[test]
    fn encoder_trim_lrps_001() {
        let graph: &NetworkGraph = &NETWORK_GRAPH;

        let config = EncoderConfig::default();

        let lrps = vec![
            LocRefPoint {
                edges: vec![EdgeId(9044472)],
                point: Point {
                    coordinate: Coordinate {
                        lon: 13.459407,
                        lat: 52.5143601,
                    },
                    line: LineAttributes {
                        frc: Frc::Frc6,
                        fow: Fow::SingleCarriageway,
                        bearing: Bearing::from_degrees(303),
                    },
                    path: Some(PathAttributes {
                        lfrcnp: Frc::Frc6,
                        dnp: Length::from_meters(14.0),
                    }),
                },
                projection_coordinate: None,
            },
            LocRefPoint {
                edges: vec![],
                point: Point {
                    coordinate: Coordinate {
                        lon: 13.4592303,
                        lat: 52.5144292,
                    },
                    line: LineAttributes {
                        frc: Frc::Frc6,
                        fow: Fow::SingleCarriageway,
                        bearing: Bearing::from_degrees(123),
                    },
                    path: None,
                },
                projection_coordinate: None,
            },
        ];

        assert_eq!(
            LocRefPoints {
                pos_offset: Length::ZERO,
                neg_offset: Length::ZERO,
                lrps: lrps.clone()
            }
            .trim(&config, graph)
            .unwrap(),
            LocRefPoints {
                pos_offset: Length::ZERO,
                neg_offset: Length::ZERO,
                lrps: lrps.clone()
            }
        );
    }

    #[test]
    fn encoder_trim_lrps_002() {
        let graph: &NetworkGraph = &NETWORK_GRAPH;

        let config = EncoderConfig::default();

        let lrps = vec![
            LocRefPoint {
                edges: vec![EdgeId(-7292030)],
                point: Point {
                    coordinate: Coordinate {
                        lon: 13.4571122,
                        lat: 52.5177995,
                    },
                    line: LineAttributes {
                        frc: Frc::Frc6,
                        fow: Fow::SingleCarriageway,
                        bearing: Bearing::from_degrees(20),
                    },
                    path: Some(PathAttributes {
                        lfrcnp: Frc::Frc6,
                        dnp: Length::from_meters(108.0),
                    }),
                },
                projection_coordinate: None,
            },
            LocRefPoint {
                edges: vec![
                    EdgeId(-7292029),
                    EdgeId(7516886),
                    EdgeId(7516883),
                    EdgeId(7516885),
                ],
                point: Point {
                    coordinate: Coordinate {
                        lon: 13.4576677,
                        lat: 52.518717,
                    },
                    line: LineAttributes {
                        frc: Frc::Frc6,
                        fow: Fow::SingleCarriageway,
                        bearing: Bearing::from_degrees(20),
                    },
                    path: Some(PathAttributes {
                        lfrcnp: Frc::Frc6,
                        dnp: Length::from_meters(94.0),
                    }),
                },
                projection_coordinate: None,
            },
            LocRefPoint {
                edges: vec![],
                point: Point {
                    coordinate: Coordinate {
                        lon: 13.4580594,
                        lat: 52.5186534,
                    },
                    line: LineAttributes {
                        frc: Frc::Frc6,
                        fow: Fow::SingleCarriageway,
                        bearing: Bearing::from_degrees(286),
                    },
                    path: None,
                },
                projection_coordinate: None,
            },
        ];

        assert_eq!(
            LocRefPoints {
                pos_offset: Length::from_meters(1.0),
                neg_offset: Length::ZERO,
                lrps: lrps.clone()
            }
            .trim(&config, graph)
            .unwrap(),
            LocRefPoints {
                pos_offset: Length::from_meters(1.0),
                neg_offset: Length::ZERO,
                lrps: lrps.clone()
            }
        );

        assert_eq!(
            LocRefPoints {
                pos_offset: Length::from_meters(108.0),
                neg_offset: Length::ZERO,
                lrps: lrps.clone()
            }
            .trim(&config, graph)
            .unwrap(),
            LocRefPoints {
                pos_offset: Length::ZERO,
                neg_offset: Length::ZERO,
                lrps: lrps[1..].to_vec()
            }
        );

        assert_eq!(
            LocRefPoints {
                pos_offset: Length::from_meters(1.0),
                neg_offset: Length::from_meters(1.0),
                lrps: lrps.clone()
            }
            .trim(&config, graph)
            .unwrap(),
            LocRefPoints {
                pos_offset: Length::from_meters(1.0),
                neg_offset: Length::from_meters(1.0),
                lrps: lrps.clone()
            }
        );

        assert_eq!(
            LocRefPoints {
                pos_offset: Length::from_meters(109.0),
                neg_offset: Length::ZERO,
                lrps: lrps.clone()
            }
            .trim(&config, graph)
            .unwrap(),
            LocRefPoints {
                pos_offset: Length::from_meters(1.0),
                neg_offset: Length::ZERO,
                lrps: lrps[1..].to_vec()
            }
        );

        assert_eq!(
            LocRefPoints {
                pos_offset: Length::ZERO,
                neg_offset: Length::from_meters(95.0),
                lrps: lrps.clone()
            }
            .trim(&config, graph)
            .unwrap(),
            LocRefPoints {
                pos_offset: Length::ZERO,
                neg_offset: Length::from_meters(1.0),
                lrps: vec![
                    lrps[0].clone(),
                    LocRefPoint {
                        edges: vec![],
                        point: Point {
                            coordinate: Coordinate {
                                lon: 13.4576677,
                                lat: 52.518717
                            },
                            line: LineAttributes {
                                frc: Frc::Frc6,
                                fow: Fow::SingleCarriageway,
                                bearing: Bearing::from_degrees(200),
                            },
                            path: None
                        },
                        projection_coordinate: None,
                    }
                ]
            }
        );
    }
}
