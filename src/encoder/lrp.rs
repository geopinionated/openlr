use std::fmt::Debug;
use std::ops::Deref;

use crate::{
    DirectedGraph, EncoderConfig, EncoderError, Frc, Length, Line, LineAttributes, Offset, Offsets,
    PathAttributes, Point,
};

#[derive(Debug, Clone, PartialEq)]
pub struct LocRefPoints<EdgeId> {
    pub lrps: Vec<LocRefPoint<EdgeId>>,
    pub pos_offset: Length,
    pub neg_offset: Length,
}

impl<EdgeId> Deref for LocRefPoints<EdgeId> {
    type Target = Vec<LocRefPoint<EdgeId>>;
    fn deref(&self) -> &Self::Target {
        &self.lrps
    }
}

impl<EdgeId> From<Vec<LocRefPoint<EdgeId>>> for LocRefPoints<EdgeId> {
    fn from(lrps: Vec<LocRefPoint<EdgeId>>) -> Self {
        Self {
            lrps,
            pos_offset: Length::ZERO,
            neg_offset: Length::ZERO,
        }
    }
}

/// Location Reference Point (LRP) generated by the encoder during the resolver step.
/// Includes the line being represented by this LRP and the shortest-path to the next LRP.
#[derive(Debug, Clone, PartialEq)]
pub struct LocRefPoint<EdgeId> {
    /// The (non-empty) shortest path to the next LRP.
    /// The line the LRP refers to is the first edge of the path.
    pub edges: Vec<EdgeId>,
    /// The Location Reference Point.
    pub point: Point,
}

impl<EdgeId: Copy> LocRefPoint<EdgeId> {
    /// Constructs a new LRP based on a node.
    pub fn from_node<G>(
        config: &EncoderConfig,
        graph: &G,
        path: Vec<EdgeId>,
    ) -> Result<Self, EncoderError>
    where
        G: DirectedGraph<EdgeId = EdgeId>,
    {
        Self::new(config, graph, path, false).ok_or(EncoderError::LrpConstructionFailed)
    }

    /// Constructs a new LRP based on the last node.
    pub fn from_last_node<G>(
        config: &EncoderConfig,
        graph: &G,
        edge: EdgeId,
    ) -> Result<Self, EncoderError>
    where
        G: DirectedGraph<EdgeId = EdgeId>,
    {
        Self::new(config, graph, vec![edge], true).ok_or(EncoderError::LrpConstructionFailed)
    }

    fn new<G>(
        config: &EncoderConfig,
        graph: &G,
        mut edges: Vec<EdgeId>,
        is_last: bool,
    ) -> Option<Self>
    where
        G: DirectedGraph<EdgeId = EdgeId>,
    {
        let line_attributes = |edge, projection, bearing_distance| {
            Some(LineAttributes {
                frc: graph.get_edge_frc(edge)?,
                fow: graph.get_edge_fow(edge)?,
                bearing: graph.get_edge_bearing_between(edge, projection, bearing_distance)?,
            })
        };

        let lrp = if is_last {
            let edge = edges.pop()?;
            let coordinate = graph.get_vertex_coordinate(graph.get_edge_end_vertex(edge)?)?;
            let projection = graph.get_edge_length(edge)?;
            let bearing_distance = config.bearing_distance.reverse();

            Self {
                edges,
                point: Point {
                    coordinate,
                    line: line_attributes(edge, projection, bearing_distance)?,
                    path: None,
                },
            }
        } else {
            let edge = *edges.first()?;
            let coordinate = graph.get_vertex_coordinate(graph.get_edge_start_vertex(edge)?)?;
            let projection = Length::ZERO;
            let bearing_distance = config.bearing_distance;

            let lfrcnp = edges.iter().filter_map(|&e| graph.get_edge_frc(e)).max();
            let dnp = edges.iter().filter_map(|&e| graph.get_edge_length(e)).sum();

            let path = PathAttributes {
                lfrcnp: lfrcnp.unwrap_or(Frc::Frc7),
                dnp,
            };

            Self {
                edges,
                point: Point {
                    coordinate,
                    line: line_attributes(edge, projection, bearing_distance)?,
                    path: Some(path),
                },
            }
        };

        Some(lrp)
    }
}

impl<EdgeId: Copy + Debug> LocRefPoints<EdgeId> {
    /// Trim the LRPs according to the positive and negative offsets.
    pub fn trim<G>(mut self, config: &EncoderConfig, graph: &G) -> Result<Self, EncoderError>
    where
        G: DirectedGraph<EdgeId = EdgeId>,
    {
        self.lrps.reverse();
        while let Some(lrp) = self.lrps.last()
            && self.pos_offset >= lrp.point.dnp()
        {
            self.pos_offset -= lrp.point.dnp();
            self.lrps.pop();
        }
        self.lrps.reverse();

        while let Some(lrp) = self.lrps.iter().rev().nth(1)
            && self.neg_offset >= lrp.point.dnp()
        {
            self.neg_offset -= lrp.point.dnp();
            self.lrps.pop();
        }

        if self.lrps.len() < 2 {
            return Err(EncoderError::LrpOffsetTrimmingFailed);
        }

        let mut lrps_rev = self.lrps.iter_mut().rev();
        if let Some(last_lrp) = lrps_rev.next().filter(|lrp| !lrp.point.is_last())
            && let Some(&last_edge) = lrps_rev.next().and_then(|lrp| lrp.edges.last())
        {
            *last_lrp = LocRefPoint::from_last_node(config, graph, last_edge)?;
        }

        Ok(self)
    }
}

impl<EdgeId> From<LocRefPoints<EdgeId>> for Line {
    fn from(lrps: LocRefPoints<EdgeId>) -> Self {
        let LocRefPoints {
            lrps,
            pos_offset,
            neg_offset,
        } = lrps;

        debug_assert!(lrps.len() > 1);
        let pos = Offset::relative(pos_offset, lrps[0].point.dnp());
        let neg = Offset::relative(neg_offset, lrps[lrps.len() - 2].point.dnp());

        Self {
            points: lrps.into_iter().map(|lrp| lrp.point).collect(),
            offsets: Offsets { pos, neg },
        }
    }
}
